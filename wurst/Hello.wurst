package Hello

import ClosureForGroups
import ClosureTimersFork
import Abilities
import EventHelper
import GameTimer
import HashMap
import OnUnitEnterLeave
import LinkedList
import UnitsApi
import Buildings

constant SETUP_TIME = 15.
constant STARTING_GOLD = 300
constant WAYPOINT_NOMINAL_RADIUS = 75.
constant LOCAL_FLOAT_LOCALITY = 256. + 128.
constant INNER_FLOAT_LOCALITY = 64. + 32.
constant SPAWN_INTERVAL = 2. // Spawn during round after this period.
constant BUILDING_ANGLE = angle(3. * PI / 2.)
constant SPAWN_POINT_PATHING_WIDTH = 128.

class Waypoints
	vec2 mid
	vec2 fin
	bool mid_visited

	construct(vec2 mid, vec2 fin)
		this.mid = mid
		this.fin = fin
		this.mid_visited = false


let creep_track = new HashMap<unit, Waypoints>()

enum CreepRoundErr
	NONE
	NO_SUCH_ROUND

tuple round_result(int val, CreepRoundErr err)

function creep_from_round(int whichRound) returns round_result
	let props = SHIP_PROPS.get(whichRound)
	if props == null
		return round_result(0, CreepRoundErr.NO_SUCH_ROUND)

	return round_result(props.id, CreepRoundErr.NONE)

function rax_id() returns int
	return ID_BARRACKS


function player.spawn_round(int whichRound, vec2 start, vec2 mid, vec2 fin, bool have_partner)
	let creep_id_res = creep_from_round(whichRound)
	if creep_id_res.err != CreepRoundErr.NONE
		return

	let u = createUnit(this, creep_id_res.val, start, angle(0.))
	if not have_partner
		u.setHP(u.getHP() / 2.)

	creep_track.put(u, new Waypoints(mid, fin))
	u.issuePointOrder("smart", mid)


function vec2.grow_to_rect(real nominal_radius) returns rect
	return Rect(this.x - nominal_radius, this.y - nominal_radius, this.x + nominal_radius, this.y + nominal_radius)


enum FindLocalFloatErr
	NONE
	NO_LOCAL_FLOAT

tuple local_float_result(vec2 res, FindLocalFloatErr err)

function vec2.is_shallow_water() returns bool
	return (
		not IsTerrainPathable(this.x, this.y, PATHING_TYPE_FLOATABILITY) and
		not IsTerrainPathable(this.x, this.y, PATHING_TYPE_WALKABILITY)
	)

function vec2.find_local_float() returns local_float_result
	for i = 0 to 7

		// The point is suitable if its surrounding areas are all floatable.
		let maybePoint = this.polarOffset(angle(2. * PI / 8 * i), LOCAL_FLOAT_LOCALITY)
		if maybePoint.is_shallow_water()
			var ander = true
			for j = 0 to 7
				let fillerPoint = maybePoint.polarOffset(angle(2. * PI / 8 * j), INNER_FLOAT_LOCALITY)
				ander = ander and fillerPoint.is_shallow_water()

			if ander
				return local_float_result(maybePoint, FindLocalFloatErr.NONE)
	return local_float_result(vec2(0., 0.), FindLocalFloatErr.NO_LOCAL_FLOAT)


function vec2.remove_walkability()
	SetTerrainPathable(this.x, this.y, PATHING_TYPE_WALKABILITY, false)

class Team
	player a
	player b
	player creep
	vec2 a_start
	vec2 b_start
	vec2 mid

	int lives

	vec2 a_waypoint
	vec2 b_waypoint
	vec2 mid_waypoint

	effect spawn_point_a
	effect spawn_point_b
	effect midpoint_fx

	construct(player a, player b, player creep)
		this.a = a
		this.b = b
		this.creep = creep
		this.a_start = a.getStartLocation()
		this.b_start = b.getStartLocation()
		this.mid = creep.getStartLocation()

		this.lives = 20

		let a_local_float_res = this.a_start.find_local_float()
		let b_local_float_res = this.b_start.find_local_float()
		let mid_local_float_res = this.mid.find_local_float()

		this.a_waypoint = a_local_float_res.res
		this.b_waypoint = b_local_float_res.res
		this.mid_waypoint = mid_local_float_res.res

		this.spawn_point_a = addEffect(Abilities.massTeleportTo, this.a_waypoint)
		this.spawn_point_b = addEffect(Abilities.massTeleportTo, this.b_waypoint)
		this.midpoint_fx = addEffect(Buildings.circleOfPower1, this.mid_waypoint)
			..setColor(155, 155, 155)
			..setColorByPlayer(Player(PLAYER_NEUTRAL_PASSIVE))

		if (
			a_local_float_res.err != FindLocalFloatErr.NONE or
			b_local_float_res.err != FindLocalFloatErr.NONE or
			mid_local_float_res.err != FindLocalFloatErr.NONE
		)
			print("Bad local float result! " + a.getId().toString() + " " + a.getNameColored())

		// Remove walkability from waypoints and spawn points.
		nullTimer() ->
			let count = (SPAWN_POINT_PATHING_WIDTH / 16.).toInt()
			for i = 0 to count
				for j = 0 to count
					(this.a_waypoint -
						vec2(16. * count / 2., 16 * count / 2.) +
						vec2(16. * i, 16. * j)).remove_walkability()
		nullTimer() ->
			let count = (SPAWN_POINT_PATHING_WIDTH / 16.).toInt()
			for i = 0 to count
				for j = 0 to count
					(this.b_waypoint -
						vec2(16. * count / 2., 16 * count / 2.) +
						vec2(16. * i, 16. * j)).remove_walkability()
		nullTimer() ->
			let count = (SPAWN_POINT_PATHING_WIDTH / 16.).toInt()
			for i = 0 to count
				for j = 0 to count
					(this.mid_waypoint -
						vec2(16. * count / 2., 16 * count / 2.) +
						vec2(16. * i, 16. * j)).remove_walkability()

	ondestroy
		this.spawn_point_a.destr()
		this.spawn_point_b.destr()
		this.midpoint_fx.destr()

	// Spawn a whole wave.
	function do_round_spawn(int whichRound)
		doPeriodicallyCounted(SPAWN_INTERVAL, 10) cb ->
			if this.lives > 0
				if this.a.isIngame()
					this.creep.spawn_round(whichRound, this.a_waypoint, this.mid_waypoint, this.b_waypoint, this.b.isIngame())
				if this.b.isIngame()
					this.creep.spawn_round(whichRound, this.b_waypoint, this.mid_waypoint, this.a_waypoint, this.a.isIngame())


function round_from_cb_count(int cb_count) returns int
	return (wave_count() + 1 - cb_count)

let teams = new LinkedList<Team>()..add(
	new Team(Player(0), Player(1), Player(8)),
	new Team(Player(2), Player(3), Player(9)),
	new Team(Player(4), Player(5), Player(10)),
	new Team(Player(6), Player(7), Player(11))
)

function get_team_from_creep(unit u) returns Team
	let owner = u.getOwner()
	return teams.filter((team) -> team.creep == owner).get(0)

init
	// Setup next-waypoint.
	let midpoint_trig = CreateTrigger()
	teams.forEach() team ->
		midpoint_trig.registerRectEnterEventSource(
			team.mid_waypoint.grow_to_rect(WAYPOINT_NOMINAL_RADIUS)
		)
	midpoint_trig.addAction() ->
		if creep_track.has(GetTriggerUnit())
			let waypoints = creep_track.get(GetTriggerUnit())
			waypoints.mid_visited = true

			GetTriggerUnit().issuePointOrder("smart", waypoints.fin)

	// Setup barracks.
	teams.forEach() team ->
		if team.a.isIngame()
			createUnit(team.a, rax_id(), team.a_start, BUILDING_ANGLE)
			createUnit(team.a, rax_id(), team.mid - vec2(256., 0.), BUILDING_ANGLE)

		if team.b.isIngame()
			createUnit(team.b, rax_id(), team.b_start, BUILDING_ANGLE)
			createUnit(team.b, rax_id(), team.mid + vec2(256., 0.), BUILDING_ANGLE)

	// Setup starting gold.
	teams.forEach() team ->
		if team.a.isIngame()
			team.a.setGold(STARTING_GOLD)
		if team.b.isIngame()
			team.b.setGold(STARTING_GOLD)

	// Setup bounty.
	teams.forEach() team ->
		team.creep.setState(PLAYER_STATE_GIVES_BOUNTY, 1)

		// This creep will attack its embargo team if blocked.
		team.creep.setPlayerAlliance(team.a, ALLIANCE_PASSIVE, false)
		team.creep.setPlayerAlliance(team.b, ALLIANCE_PASSIVE, false)

		// Others are allied to this creep.
		teams.forEach() otherTeam ->
			if otherTeam.creep != team.creep
				otherTeam.a.setPlayerAlliance(team.creep, ALLIANCE_PASSIVE, true)
				otherTeam.b.setPlayerAlliance(team.creep, ALLIANCE_PASSIVE, true)

	// Misc setup.
	FogEnable(false)
	FogMaskEnable(false)

	// Setup end-of-the-line.
	let endpoint_trig = CreateTrigger()
	teams.forEach() team ->
		endpoint_trig.registerRectEnterEventSource(team.a_waypoint.grow_to_rect(WAYPOINT_NOMINAL_RADIUS))
		endpoint_trig.registerRectEnterEventSource(team.b_waypoint.grow_to_rect(WAYPOINT_NOMINAL_RADIUS))
	endpoint_trig.addAction() ->
		if creep_track.has(GetTriggerUnit())
			let waypoints = creep_track.get(GetTriggerUnit())
			if waypoints.mid_visited
				let team_blob = get_team_from_creep(GetTriggerUnit())
				addEffect(Abilities.massTeleportTarget, GetTriggerUnit().getPos()).destr()
				team_blob.lives--
				if team_blob.lives <= 0
					print("Team " + team_blob.a.getName() + " & " + team_blob.b.getName() + " was defeated!")
					nullTimer() ->
						forUnitsOfPlayer(team_blob.a) u ->
							u.remove()
						forUnitsOfPlayer(team_blob.b) u ->
							u.remove()
						forUnitsOfPlayer(team_blob.creep) u ->
							u.remove()
				creep_track.remove(GetTriggerUnit())
				destroy waypoints

				GetTriggerUnit().remove()

	onLeave() ->
		if creep_track.has(GetTriggerUnit())
			// Destroy creep_track waypoints.
			destroy creep_track.getAndRemove(GetTriggerUnit())

	doAfter(SETUP_TIME) ->
		let cb = doPeriodicallyCounted(40., wave_count() + 1) cb ->
			if not cb.isLast()
				let rd = round_from_cb_count(cb.getCount())
				print("|cffffcc00Round " + rd.toString() + ":|r " + SHIP_PROPS.get(rd).name)

				teams.forEach() team ->
					team.do_round_spawn(rd)
			else
				print("|cffffcc00You win!  Congratulations.|r")
				print("    |cff999999Game time: " + (getElapsedGameTime() / 60.).toInt().toString() + " minutes.|r")
				doAfter(20.) ->

					// Destroy teams.
					teams.forEach() team ->
						destroy team
					destroy teams

					// Destroy creep_track.
					destroy creep_track

					// End the game.
					teams.forEach() team ->
						if team.lives > 0
							RemovePlayer(team.a, PLAYER_GAME_RESULT_VICTORY)
							RemovePlayer(team.b, PLAYER_GAME_RESULT_VICTORY)
						else
							RemovePlayer(team.a, PLAYER_GAME_RESULT_DEFEAT)
							RemovePlayer(team.b, PLAYER_GAME_RESULT_DEFEAT)
					EndGame(true)
		cb.setupDialogCallback() cb ->
			let round = round_from_cb_count(cb.getCount())
			var status = dialog_update_fn_res("Victory", false)

			if round < SHIP_PROPS.size()
				status = dialog_update_fn_res("Round " + round.toString(), true)

			return status
